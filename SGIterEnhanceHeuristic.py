#!/usr/bin/env python3
'''
Given a graph build by makeGraphFromOverlap.py, let M be its weighted adjmatrix,
compute T = M^1+M^2+...+M^n. In T, let (i, j) be a largest entry, set i and j
to be the two ends of the first (and only) interval and recursively add vertices
in between to split an interval into two, s.t. for an existing interval (u,v),
the inserted element m satisfies (u,m)+(m,v) is the largest among all free (i.e.,
haven't used) vertices.
'''


import sys
import os.path
import itertools
import numpy as np
from graph_tool.all import *
from sortedcontainers import SortedList
import scipy

# M is a 2d scipy.sparse.csr_matrix of dtype=int, n is an integer
# return M+M^2+...+M^n
def nTC(M, n):
   I = scipy.sparse.identity(M.shape[0], dtype=int)
   if n <= 0:
      return I
   elif n == 1:
      return M
   else:
      R = (I + M) @ M
      while n > 2:
         R = (I + R) @ M
         n -= 1
      return R


#g here is the unfiltered graph so we can recognize ground truth pairs
def output_in_dot(g, ordered, out_filename):
   names = g.vp.id.a
   height = 0
   height_diff = -80
   with open(out_filename, 'w') as fout:
      fout.write('digraph{\ngraph [splines=line];\nnode [width=1.2, height=.1];\n')
      for i in range(g.num_vertices()):
         fout.write(f'r{names[i]} [pos=\"80,{height}\", label=\"{names[i]}\", xlabel=\"{ordered[i]}\"];\n')
         height += height_diff
      
      fout.write('edge [penwidth=2.0, color=\"lime\", fontcolor=\"limegreen\"]\n')
      for i in range(1, g.num_vertices()):
         if ordered[i] - ordered[i-1] == 1:
            e = g.edge(i-1, i)
            if (e is None) or (g.ep.weight[e] == 0):
               fout.write(f'r{names[i-1]} -> r{names[i]} [label=\"discovered\"];\n')
            else:
               fout.write(f'r{names[i-1]} -> r{names[i]} [label=\"{g.ep.weight[e]}\"];\n')

      sorted_ordered = np.argsort(ordered)
      for i in range(1, g.num_vertices()):
         s = sorted_ordered[i-1]
         t = sorted_ordered[i]
         if t - s == 1:
            continue

         e = g.edge(s,t)
         w = "discovered" if (e is None) or (g.ep.weight[e] == 0) else g.ep.weight[e]
         y = ((s+t)*height_diff)>>1
         if e is not None and g.ep.type[e] > 0:
            x =  140 + (t-s)*height_diff
            fout.write(f'r{names[s]}midr{names[t]} [pos=\"{x},{y}\", shape=none, fontcolor=\"blue\", label=\"{w}\"];\n')
            fout.write(f'r{names[s]} -> r{names[s]}midr{names[t]}:c [dir=\"none\", color=\"cyan\"];\n')
            fout.write(f'r{names[s]}midr{names[t]}:c -> r{names[t]} [color=\"cyan\"];\n')
         else:
            x = 160 + 4*abs(t-s)
            fout.write(f'r{names[s]}midr{names[t]} [pos=\"{x},{y}\", shape=none, fontcolor=\"red\", label=\"{w}\"];\n')
            fout.write(f'r{names[s]} -> r{names[s]}midr{names[t]}:c [dir=\"none\", color=\"red\"];\n')
            fout.write(f'r{names[s]}midr{names[t]}:c -> r{names[t]} [color=\"red\"];\n')

      fout.write('}\n')


def main(argc, argv):
   dir = "sample-reads"
   header_ext = "header-sorted"
   found_ext = "all-pair"
   true_ext = "truepairs-directed"

   if argc != 2:
      print("Usage: SGFeedbackArcHeuristic.py <graph>")
      print("graph is generated by makeGraphFromOverlap.py")
      print('Example: SGFeedbackArcHeuristic.py sample-reads/sim-e-coli-pb-le20k-nosub-n60-k42-t0/unionPos.graphml')
      exit(1)


   head, sep, tail = argv[1].rpartition('.')
   result_filename = (head if sep else tail) + '.FAH.dot'

   #check the input file exists
   input_name = argv[1]
   if not os.path.isfile(input_name):
      print(f'Cannot read node file: {input_name}')
      exit(1)


   fg = Graph()
   fg.load(input_name)

   g = GraphView(fg, efilt=fg.ep.weight.a>0)

   A = scipy.sparse.csr_matrix(adjacency(g, weight=g.ep.weight).transpose(), dtype=int)
   
   B = nTC(A, 10)

   

   output_in_dot(fg, ordered, result_filename)


if __name__ == "__main__":
   sys.exit(main(len(sys.argv), sys.argv))
   
